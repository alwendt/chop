From salomon@silver.cs.umanitoba.ca Tue Dec 14 10:21:32 MST 1993
Article: 3404 of comp.compilers
Xref: yuma comp.compilers:3404 comp.arch:19177
Newsgroups: comp.compilers,comp.arch
Path: yuma!purdue!haven.umd.edu!news.umbc.edu!europa.eng.gtefsd.com!uunet!world!iecc!compilers-sender
From: salomon@silver.cs.umanitoba.ca (Daniel J. Salomon)
Subject: Re: SPARC code generation for compiler course
Message-ID: <93-12-053@comp.compilers>
Keywords: architecture, courses, sparc
Sender: compilers-sender@chico.iecc.com
Organization: Computer Science, University of Manitoba, Winnipeg, Canada
References: <93-12-040@comp.compilers>
Date: Mon, 13 Dec 1993 18:10:53 GMT
Approved: compilers@chico.iecc.com
Lines: 62

mackey@cse.ucsc.edu (Wesley Mackey ) writes:
> I'm teaching a course in code generation next quarter and am looking for
> SPARC documention which is more student oriented than the hardware
> manuals.  I need a more cookbook approach along with an architectural
> description that can be passed out to students without expecting them to
> read for hours and hours.

I have used the SPARC architecture manual in my course without too much
trouble.  I give them an introduction to the SPARC architecture and some
sample programs so they don't have to read "for hours and hours."  They
just use the architecture manual as a reference.  They also need the
assembler language reference manual available in the online "answerbook".
Let me know if you do find a briefer introduction, though, if it is less
expensive than the architecture manual.

> Also, is there any documentation about %global and %floating register
> conventions?  I've seen a reference to a SPARC ABI, but nothing complete.

The SPARC ABI is available as:
"AT&T System V Application Binary Interface: SPARC Processor Supplement"
published by UNIX Press (a special sales division of Prentice-Hall)
ISBN 0-13-877630-X
Do not have the students buy this manual because it is quite expensive,
and there are only a few sentences of information that are not available
in other manuals.

> Specifically, are [the registers] caller-preserved or callee-preserved?
> Use of the %o, %l, %i regs are obvious from the architecture.

The floating registers are caller-preserved.  The %o, %l, and %i registers
are rotated by the callee to obtain a new window in the register bank, and
so are not saved explicitly by either the caller or the callee.  If the
register bank is full, the reused window is saved on the stack
automatically by the hardware.  The global registers have the following
duties:
    %g0  always contains zero
    %g1  very volatile, a general purpose short term temporary register.
    %g2, %g3, and %g4  for use by the programmer
    %g5, %g6, and %g7  reserved for the operating system.

Inspecting the code generated by the C compiler can also answer some
other questions although sometimes it can get pretty mysterious.

> Any detailed description of the memory stack frame conventions?

The stack frame conventions are given in the SPARC Architecture Manual
Appendix D, and again in the ABI.  One important point is not to use the
program stack for temporaries.  The SPARC expects the stack structure to
be consistent at all times so it can save overflow register windows
properly.

It does take quite a while to get this information nailed down properly.
I was teaching the course for three years before I finally got the
majority of the class to hand in completed compiler projects that include
user defined procedures with parameters.
--
Daniel J. Salomon -- salomon@cs.UManitoba.CA
       Dept. of Computer Science / University of Manitoba
       Winnipeg, Manitoba, Canada  R3T 2N2 / (204) 474-8687
-- 
Send compilers articles to compilers@iecc.com or
{ima | spdcc | world}!iecc!compilers. Meta-mail to compilers-request@iecc.com.


From chase@Think.COM Tue Dec 14 10:21:53 MST 1993
Article: 3406 of comp.compilers
Xref: yuma comp.compilers:3406 comp.arch:19185
Newsgroups: comp.compilers,comp.arch
Path: yuma!purdue!lerc.nasa.gov!usenet.ins.cwru.edu!howland.reston.ans.net!europa.eng.gtefsd.com!uunet!world!iecc!compilers-sender
From: chase@Think.COM (David Chase)
Subject: Re: SPARC code generation for compiler course
Message-ID: <93-12-055@comp.compilers>
Keywords: architecture, sparc
Sender: compilers-sender@chico.iecc.com
Organization: Thinking Machines Corporation, Cambridge MA, USA
References: <93-12-040@comp.compilers> <93-12-053@comp.compilers>
Date: Mon, 13 Dec 1993 21:22:33 GMT
Approved: compilers@chico.iecc.com
Lines: 78

salomon@silver.cs.umanitoba.ca (Daniel J. Salomon) writes:

|> The floating registers are caller-preserved.  The %o, %l, and %i registers
|> are rotated by the callee to obtain a new window in the register bank, and
|> so are not saved explicitly by either the caller or the callee.  If the
|> register bank is full, the reused window is saved on the stack
|> automatically by the hardware.

Err, I think this is a little misleading.  From the caller's point of view,
a called subroutine must preserve the following:

  %i, %l registers.
  %o6, unless specified otherwise (that is, altering the stack pointer
       is only allowed under certain circumstances and with certain
       handshakes going on).

  %o0-%o7 are otherwise free to be modified by the called subroutine.

The register saving by the called subroutine is NOT automatic -- execution
of a SAVE instruction in the prologue of the called subroutine is what makes
that happen.  If there is no window available, there is a trap to the OS,
(not the hardware) which fixes it up.

|> > Any detailed description of the memory stack frame conventions?
|>
|> The stack frame conventions are given in the SPARC Architecture Manual
|> Appendix D, and again in the ABI.  One important point is not to use the
|> program stack for temporaries.  The SPARC expects the stack structure to
|> be consistent at all times so it can save overflow register windows
|> properly.

Again, close, but not quite right.  The register window save area, at SP+0
through SP+63 (that is, 16 registers) must be regarded as possibly being
written OR read at any point at all -- that is, leave it alone.  However,
the rest of the stack is not so volatile, and may well be used for storage
of temporaries.  See "certain handshakes" above, however for dealing with
allocation of SP-relative temporaries.  Basically, "alloca" has to be
passed a secret (compiler-generated) parameter that informs it as to how
large the SP-relative temp area is, and it has to move those temps when it
slides the stack.

Here's some more info on the calling conventions, from memory (you might
want to check these with a compiler):

SP+64-67 ==> structure return pointer

SP+68,72,76,80,84,88 ==> reserved memory for storage of parameter
  registers in the event of varargs (the compiler is NOT required to
  store them here, but it MAY).

SP+92 and beyond ==> additional parameters beyond the first six words.

Note that one thing that a SAVE instruction does is that it turns the
caller's SP (%o6) into the callee's FP (%i6).  Note that a SAVE
instruction also performs a peculiar sort of addition, in that it the
addressed registers are from both the old and new bank, as in:

  SAVE old_SP,-96,new_SP

  old_SP is %o6 in the caller's (old) window,
  new_SP is %o6 in the callee's (new) window.

|> It does take quite a while to get this information nailed down properly.

Yes, agreed.  I hope this is helpful.  In general, it pays to read the
books, look at the code that is generated, and take yourself through the
prologue and epilogue step-by-step.  Think about the nasty corner cases,
too, like setjmp and longjmp -- those can prevent you from doing things
that would otherwise be quite reasonable, depending upon assumptions made
by compilers-and/or-programmers about the state of registers post-longjmp.

In general, there's an awful lot to learn here -- it's ALL details.

David Chase, speaking for myself.
Thinking Machines
-- 
Send compilers articles to compilers@iecc.com or
{ima | spdcc | world}!iecc!compilers. Meta-mail to compilers-request@iecc.com.


From kelvin@cs.iastate.edu Tue Dec 14 10:36:23 1993
Received: from flash.cs.iastate.edu by beethoven (4.1/SMI-4.1)
	id AA10125; Tue, 14 Dec 93 10:36:19 MST
Received: from kickapoo.cs.iastate.edu by flash.cs.iastate.edu with SMTP
	(1.37.109.6/16.2) id AA09061; Tue, 14 Dec 93 11:35:13 -0600
Received: by kickapoo.cs.iastate.edu (5.0/SMI-SVR4)
	id AA13908; Tue, 14 Dec 1993 11:35:08 +0600
Date: Tue, 14 Dec 1993 11:35:08 +0600
From: kelvin@cs.iastate.edu (Kelvin Nilsen)
Message-Id: <9312141735.AA13908@kickapoo.cs.iastate.edu>
To: dh@hermes.mod.uk, armbru@karlsruhe.gmd.de, cwf@research.att.com,
        wendt@CS.ColoState.EDU
Subject: information on sparc processors
Content-Length: 5631
Status: OR


Hi,

  Here's a compilation of responses to our recent request for technical
descriptions of sparc-family processors...




Return-Path: <krueger@splat.micro.ti.com>
Date: Tue, 23 Nov 93 14:42:54 CST
From: krueger@splat.micro.ti.com (Steve Krueger)
To: kelvin@cs.iastate.edu
Subject: Re: Pipeline details of various Sun Architectures
Newsgroups: comp.arch,comp.sys.sun.hardware,comp.compilers
References: <93-11-126@comp.compilers>
Content-Type: text
Content-Length: 800

In comp.arch you write:

Kelvin,

I can have a copy of the SuperSPARC Users Guide sent to you if you
send me a complete US mail address.  Our Users Guide generally
contains the information you seek, although not always in a direct
tabular form.

	-Steve Krueger			krueger@micro.ti.com
	 SPARC Applications
	 Texas Instruments
	 Houston, Texas USA



----------------------------------------------------------------------

*************************************************************************
		 Just Published from SunSoft Press
*************************************************************************


                MULTIPROCESSOR SYSTEM ARCHITECTURES:
        A Technical Survey of Multiprocessor/Multithreaded Systems 
      using SPARC, Multi-level Bus Architectures and Solaris (SunOS)

                      by Ben Catanzaro


This book is the first of its kind to bring together in one volume a
coherent description of the elements that provide for the design and
development of multiprocessor systems from Sun Microsystems, Inc.  It
includes new technology that integrates packet-switched buses and
multithreading techniques in the implementation of multiprocessor
systems.

Multiprocessor System Architectures can serve as a reference text for
design engineers as well as a hands-on design guide to multiprocessor
systems that provides both hardware and software engineers with a
coherent understanding of the problems and solutions to multiprocessor
system design.

Topics covered include:

. Reviews design considerations associated with multiprocessor systems and 
  presents practical solutions 

. Provides an indepth study on the Scalable Processor ARChitecture (SPARC)
  and details the various SPARC implementations 

. Introduces and details various multi-level bus architectures including 
  MBus (a processor-level interconnect bus) and XBus/XDBus (packet switched    
  buses)  

. Discusses the use of the SPARC MPSAS Behavioral Simulator to model SPARC 
  multiprocessor systems with many design examples 

. Introduces and details components of the Solaris/SunOS multithreaded 
  architecture such as threads, lightweight processes, synchronization, 
  scheduling, preemption, real-time facilities, and programming

. Examines several multiprocessor system implementations by
  highlighting tightly coupled, shared-memory model architectures using
  multi-level bus implementations such as MBus and XDBus

. Provides an MBus Interface Specification and Design Guide that conveys
  significant aspects of designing MBus modules


ISBN 013-089137-1       500 pages        $42.00 US (suggested list price)        

-------------------------------------------------------------------------
                         CUSTOMER ORDER INFORMATION
-------------------------------------------------------------------------

Books are available through:

(1) technical bookstores worldwide, or 

(2) through SunExpress at 1-800-USE-SUNX or 1-800-873-7869
    after December 15, 1993.

(3) directly from the publishers (see online book catalog below)


---------------------------------------------------------------------------
                            ONLINE BOOK CATALOG
-----------------------------------------------------------------------------

For a complete SunSoft Press book catalog with customer order
information, please email:

	               sunsoftpress@Sun.com

----------------------------------------------------------------------
From: ?????  (Sorry, i'm not sure who Greg is?)

The best source of information is the T.I. SuperSPARC User's
guide. It has all the details on the pipeline that you'll
need, including the "grouping rules" which define how the
processor decides what it can or cannot do in a given cycle.

The hard part of your project is not simulating the
pipeline; it's the rest of the machine. Getting all
the details right on the instruction cache/fetch/prefetch,
MMU refill algorithms, etc. is very hard. Once again, the
user's guide is the best source of information.

TI has just recently completed a new release of this document
which is far superior to the orignal. The TI part number is
2647726-9761. Revision A "Beta" Review from October 1993.

Call your local TI office to get a copy of this.

If you have any specific questions, I'd be happy to try and
answer them.

-Greg


----------------------------------------------------------------------

Date: Thu, 25 Nov 93 23:01:52 PST
From: Gordon.Irlam@Eng.Sun.COM (Gordon Irlam)
Subject: Re: a guide to compiler writers for sparcstations

I didn't write a thesis (god forbid), but you might want to have a look at
ftp.cs.adelaide.edu.au:/pub/sparc.  There is a note describing some old
SPARC machines, and a slightly out of date SPARC simulator.

                                                 Gordon.


----------------------------------------------------------------------
Return-Path: <wendt@ives.CS.ColoState.EDU>
Date: Mon, 13 Dec 93 15:46:20 -0700
From: wendt@cs.colostate.edu (alan l wendt)


They sell a "SPARC Architecture manual" for $37, including complete instruction
set definition.  1-800-453-6657 or sparcshop@sparc.com




From markt@harlequin.co.uk Wed Dec 15 09:49:46 MST 1993
Article: 3408 of comp.compilers
Xref: yuma comp.compilers:3408 comp.arch:19215
Newsgroups: comp.compilers,comp.arch
Path: yuma!purdue!lerc.nasa.gov!usenet.ins.cwru.edu!uuspew.uu.net!uunet!world!iecc!compilers-sender
From: markt@harlequin.co.uk (Mark Tillotson)
Subject: Re: SPARC code generation for compiler course
Message-ID: <93-12-059@comp.compilers>
Keywords: sparc, courses
Sender: compilers-sender@chico.iecc.com
Organization: Harlequin Limited, Cambridge, England
References: <93-12-040@comp.compilers> <93-12-053@comp.compilers>
Date: Tue, 14 Dec 1993 16:15:23 GMT
Approved: compilers@chico.iecc.com
Lines: 47

salomon@silver.cs.umanitoba.ca (Daniel J. Salomon) writes:
>
>     %g0  always contains zero
>     %g1  very volatile, a general purpose short term temporary register.
>     %g2, %g3, and %g4  for use by the programmer
>     %g5, %g6, and %g7  reserved for the operating system.
>
As I understand it g1/g2/g3/g4 and all the floating point registers
are caller save, g5/g6/g7 are reserved for the `execution environment'
or some such wording---does anyone know what this means? (they are of
no use to the kernel in a multi-tasking environment because they are
not supervisor-mode only).  The wording ``very volatile'' can mean
nothing stronger than caller saved without making the register unusable.


> The stack frame conventions are given in the SPARC Architecture Manual
> Appendix D, and again in the ABI.  One important point is not to use the
> program stack for temporaries.     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

This isn't true---there is no problem at all with allocating
temporaries on the stack so long as you move %o6 down in multiples of
8.  (C compilers seem to just preallocate the whole stack frame once in
the save instruction anyway)

>             ... The SPARC expects the stack structure to
> be consistent at all times so it can save overflow register windows
> properly.

  Window overflow, clean or flush can potentially happen between any two
instructions due to asynchronous events.  Thus you cannot expect invalid
windows to remain unchanged (they could be zeroed), %o6 must point to a
valid 64 byte save area in the address space, and be 8-byte aligned.  The
chain from %i6 must be valid for all the valid register windows (those not
flushed to memory).

  Also signal handling can trample the area immediately
below %o6 unless a seperate signal stack can be set up... thus keep
%o6's save area at the bottom of the stack frame below local
variables/temporaries.
--
M. Tillotson       Harlequin Ltd.
markt@uk.co.harlqn  Barrington Hall,
+44 223 872522       Barrington, UK
-- 
Send compilers articles to compilers@iecc.com or
{ima | spdcc | world}!iecc!compilers. Meta-mail to compilers-request@iecc.com.


From lou@central.cis.upenn.edu Wed Dec 15 09:50:09 MST 1993
Article: 3411 of comp.compilers
Newsgroups: comp.compilers
Path: yuma!purdue!lerc.nasa.gov!usenet.ins.cwru.edu!howland.reston.ans.net!europa.eng.gtefsd.com!uunet!world!iecc!compilers-sender
From: lou@central.cis.upenn.edu (Richard Paul)
Subject: Sparc Architecture
Message-ID: <93-12-060@comp.compilers>
Keywords: sparc, books
Sender: compilers-sender@chico.iecc.com
Organization: University of Pennsylvania
References: <93-12-040@comp.compilers> <93-12-053@comp.compilers>
Date: Tue, 14 Dec 1993 16:30:18 GMT
Approved: compilers@chico.iecc.com
Lines: 26

I have just finished a book on SPARC Architecture which I use when I teach
the Introductory Computer Architecture course, I also use the book as a
reference when I teach the compilers course, in which we translate a
sub-set of C into SPARC assembly language.

"SPARC Architecture, Assembly Language Programming, and C," by Richard
P. Paul, Prentice Hall, ISBN 0-13-876889-7.

SPARC architecture is covered from a programmer's perspective, making use
of UNIX tools (the macro processor m4; the assembler as; the gnu editor
emacs; and the debugger gdb).  Frequent reference is made to C language
constructs and their translation.  Chapters on floating point, traps,
memory management and other architectures provide optional course
material.  All necessary reference material, including the SAPRC
instruction set, is provided in appendices.  The text is suitable for a
one semester introductory course on computer architecture.  It is also
suitable for programmers who will be programming SPARC architecture
machines in languages such as C and have concern with computational
efficiency.

Richard (Lou) Paul         Department of Computer and Information Science
email: lou@cis.upenn.edu   University of Pennsylvania
phone: 215/898-0372        Philadelphia, PA 19104-6228   fax:215/573-2048
-- 
Send compilers articles to compilers@iecc.com or
{ima | spdcc | world}!iecc!compilers. Meta-mail to compilers-request@iecc.com.


From kelvin@cs.iastate.edu Wed Dec 15 09:50:33 MST 1993
Article: 3412 of comp.compilers
Xref: yuma comp.arch:19216 comp.compilers:3412
Newsgroups: comp.arch,comp.compilers
Path: yuma!purdue!lerc.nasa.gov!usenet.ins.cwru.edu!howland.reston.ans.net!cs.utexas.edu!uunet!world!iecc!compilers-sender
From: kelvin@cs.iastate.edu (Kelvin Nilsen)
Subject: Summary of Information Available on Sparc-family processors
Message-ID: <93-12-061@comp.compilers>
Keywords: sparc, summary
Sender: compilers-sender@chico.iecc.com
Organization: Iowa State University, Ames IA
References: <93-12-040@comp.compilers> <93-12-053@comp.compilers>
Date: Tue, 14 Dec 1993 17:48:45 GMT
Approved: compilers@chico.iecc.com
Lines: 150

Several weeks ago, I requested pointers to documentation describing
Sparc-family processors.  I was especially interested in understanding
their respective pipelines.  Here's a compilation of the responses
I received.

**********************************************************************
Date: Tue, 23 Nov 93 14:42:54 CST
From: krueger@splat.micro.ti.com (Steve Krueger)
Subject: Re: Pipeline details of various Sun Architectures

I can have a copy of the SuperSPARC Users Guide sent to you if you
send me a complete US mail address.  Our Users Guide generally
contains the information you seek, although not always in a direct
tabular form.

	-Steve Krueger			krueger@micro.ti.com
	 SPARC Applications
	 Texas Instruments
	 Houston, Texas USA



----------------------------------------------------------------------

*************************************************************************
		 Just Published from SunSoft Press
*************************************************************************


                MULTIPROCESSOR SYSTEM ARCHITECTURES:
        A Technical Survey of Multiprocessor/Multithreaded Systems
      using SPARC, Multi-level Bus Architectures and Solaris (SunOS)

                      by Ben Catanzaro


This book is the first of its kind to bring together in one volume a
coherent description of the elements that provide for the design and
development of multiprocessor systems from Sun Microsystems, Inc.  It
includes new technology that integrates packet-switched buses and
multithreading techniques in the implementation of multiprocessor
systems.

Multiprocessor System Architectures can serve as a reference text for
design engineers as well as a hands-on design guide to multiprocessor
systems that provides both hardware and software engineers with a
coherent understanding of the problems and solutions to multiprocessor
system design.

Topics covered include:

. Reviews design considerations associated with multiprocessor systems and
  presents practical solutions

. Provides an indepth study on the Scalable Processor ARChitecture (SPARC)
  and details the various SPARC implementations

. Introduces and details various multi-level bus architectures including
  MBus (a processor-level interconnect bus) and XBus/XDBus (packet switched
  buses)

. Discusses the use of the SPARC MPSAS Behavioral Simulator to model SPARC
  multiprocessor systems with many design examples

. Introduces and details components of the Solaris/SunOS multithreaded
  architecture such as threads, lightweight processes, synchronization,
  scheduling, preemption, real-time facilities, and programming

. Examines several multiprocessor system implementations by
  highlighting tightly coupled, shared-memory model architectures using
  multi-level bus implementations such as MBus and XDBus

. Provides an MBus Interface Specification and Design Guide that conveys
  significant aspects of designing MBus modules


ISBN 013-089137-1       500 pages        $42.00 US (suggested list price)

-------------------------------------------------------------------------
                         CUSTOMER ORDER INFORMATION
-------------------------------------------------------------------------

Books are available through:

(1) technical bookstores worldwide, or

(2) through SunExpress at 1-800-USE-SUNX or 1-800-873-7869
    after December 15, 1993.

(3) directly from the publishers (see online book catalog below)


---------------------------------------------------------------------------
                            ONLINE BOOK CATALOG
-----------------------------------------------------------------------------

For a complete SunSoft Press book catalog with customer order
information, please email:

	               sunsoftpress@Sun.com

----------------------------------------------------------------------
From: ?????  (Sorry, i'm not sure who Greg is?)

The best source of information is the T.I. SuperSPARC User's
guide. It has all the details on the pipeline that you'll
need, including the "grouping rules" which define how the
processor decides what it can or cannot do in a given cycle.

The hard part of your project is not simulating the
pipeline; it's the rest of the machine. Getting all
the details right on the instruction cache/fetch/prefetch,
MMU refill algorithms, etc. is very hard. Once again, the
user's guide is the best source of information.

TI has just recently completed a new release of this document
which is far superior to the orignal. The TI part number is
2647726-9761. Revision A "Beta" Review from October 1993.

Call your local TI office to get a copy of this.

If you have any specific questions, I'd be happy to try and
answer them.

-Greg


----------------------------------------------------------------------

Date: Thu, 25 Nov 93 23:01:52 PST
From: Gordon.Irlam@Eng.Sun.COM (Gordon Irlam)
Subject: Re: a guide to compiler writers for sparcstations

I didn't write a thesis (god forbid), but you might want to have a look at
ftp.cs.adelaide.edu.au:/pub/sparc.  There is a note describing some old
SPARC machines, and a slightly out of date SPARC simulator.

                                                 Gordon.


----------------------------------------------------------------------
Return-Path: <wendt@ives.CS.ColoState.EDU>
Date: Mon, 13 Dec 93 15:46:20 -0700
From: wendt@cs.colostate.edu (alan l wendt)

They sell a "SPARC Architecture manual" for $37, including complete
instruction set definition.  1-800-453-6657 or sparcshop@sparc.com
-- 
Send compilers articles to compilers@iecc.com or
{ima | spdcc | world}!iecc!compilers. Meta-mail to compilers-request@iecc.com.


From salomon@silver.cs.umanitoba.ca Thu Dec 16 08:50:49 MST 1993
Article: 3420 of comp.compilers
Xref: yuma comp.compilers:3420 comp.arch:19240
Newsgroups: comp.compilers,comp.arch
Path: yuma!purdue!haven.umd.edu!news.umbc.edu!eff!usenet.ins.cwru.edu!nigel.msen.com!yale.edu!yale!hsdndev!spdcc!iecc!compilers-sender
From: salomon@silver.cs.umanitoba.ca (Daniel J. Salomon)
Subject: Re: SPARC code generation for compiler course
Message-ID: <93-12-069@comp.compilers>
Keywords: architecture, courses, sparc
Sender: compilers-sender@chico.iecc.com
Organization: Computer Science, University of Manitoba, Winnipeg, Canada
References: <93-12-040@comp.compilers> <93-12-053@comp.compilers>
Date: Wed, 15 Dec 1993 18:18:43 GMT
Approved: compilers@chico.iecc.com
Lines: 19

I wrote:
> One important point is not to use the program stack for temporaries.
> The SPARC expects the stack structure to be consistent at all times so
> it can save overflow register windows properly.

Many readers have misinterpreted this statement.  What I was actually
warning against was using the top of the stack for expression evaluation,
like in a real stack machine.  Some of my students were doing this and
always getting their stack values clobbered by register saves.  The top of
the stack must be kept ready to to hold saved registers.  You can still,
of course, use the stack for holding local variables, as long as they are
only semi-dynamic.
--
Daniel J. Salomon -- salomon@cs.UManitoba.CA
       Dept. of Computer Science / University of Manitoba
       Winnipeg, Manitoba, Canada  R3T 2N2 / (204) 474-8687
-- 
Send compilers articles to compilers@iecc.com or
{ima | spdcc | world}!iecc!compilers. Meta-mail to compilers-request@iecc.com.


From pardo@cs.washington.edu Thu Dec 16 14:49:11 MST 1993
Article: 3421 of comp.compilers
Xref: yuma comp.compilers:3421 comp.arch:19258
Newsgroups: comp.compilers,comp.arch
Path: yuma!purdue!haven.umd.edu!news.umbc.edu!eff!news.kei.com!world!iecc!compilers-sender
From: pardo@cs.washington.edu (David Keppel)
Subject: Re: SPARC code generation for compiler course
Message-ID: <93-12-070@comp.compilers>
Keywords: sparc, report, FTP
Sender: compilers-sender@chico.iecc.com
Organization: Computer Science & Engineering, U. of Washington, Seattle
References: <93-12-040@comp.compilers> <93-12-059@comp.compilers>
Date: Thu, 16 Dec 1993 01:41:05 GMT
Approved: compilers@chico.iecc.com
Lines: 20

>[SPARC stack layout for window overflow and underflow.]

For an alternative description of the stack layout see (blowing my own horn):

%A David Keppel
%T Register Windows and User-Space Threads on the SPARC
%R 91-08-01
%I University of Washington
%C Seattle, Washington
%D August 1991

Available via anonymous ftp from `ftp.cs.washington.edu'
(128.95.1.4) in `tr/1991/08/UW-CSE-91-08-01.PS.Z'.  It is
compressed PostScript(tm) so be sure to do the transfer
in binary (image) mode.

		;-D on  ( Threadbare )  Pardo
-- 
Send compilers articles to compilers@iecc.com or
{ima | spdcc | world}!iecc!compilers. Meta-mail to compilers-request@iecc.com.


From nickh@harlequin.co.uk Thu Dec 16 14:50:05 MST 1993
Article: 3423 of comp.compilers
Xref: yuma comp.compilers:3423 comp.arch:19259
Newsgroups: comp.compilers,comp.arch
Path: yuma!purdue!haven.umd.edu!news.umbc.edu!eff!news.kei.com!world!iecc!compilers-sender
From: nickh@harlequin.co.uk (Nick Haines)
Subject: Re: SPARC code generation for compiler course
Message-ID: <93-12-072@comp.compilers>
Keywords: sparc, architecture
Sender: compilers-sender@chico.iecc.com
Organization: Harlequin Limited, Cambridge, England
References: <93-12-040@comp.compilers> <93-12-059@comp.compilers>
Date: Thu, 16 Dec 1993 10:12:46 GMT
Approved: compilers@chico.iecc.com
Lines: 34

markt@harlequin.co.uk (Mark Tillotson) writes:

   As I understand it g1/g2/g3/g4 and all the floating point registers
   are caller save, g5/g6/g7 are reserved for the `execution environment'
   or some such wording---does anyone know what this means? (they are of
   no use to the kernel in a multi-tasking environment because they are
   not supervisor-mode only).

"The current convention is that the global registers (except %g0) are
assumed to be volatile across procedure calls. The convention used by the
SPARC Application Binary Interface (ABI) is that %g1 is assumed to be
volatile across procedure calls, %g2 ... %g4 are reserved for use by the
application program (for example, as global register variables), and %g5
... %g7 are assumed to be nonvolatile and reserved for (as-yet-undefined)
use by the execution environment."

(SPARC architecture manual version 8).

SO clearly when not adhering to the ABI, g1-g7 are caller save (unless one
defines one's own convention, as compiler writers are free to do).

When adhering to the ABI, the meaning is not clear, and probably requires
reading the Sparc ABI definition. Any Sun experts out there want to
comment?  My non-expert eye says that g1 is caller-save, g2-g4 are up to
the compiler writer (caller-save, or global variables, or some kind of
program state; this is what is meant by "the execution environment"
elsewhere in the manual) and g5-g7 are "reserved" to the ABI (although how
the ABI copes with non-conforming code is unstated).

Nick Haines
nickh@harlequin.co.uk
-- 
Send compilers articles to compilers@iecc.com or
{ima | spdcc | world}!iecc!compilers. Meta-mail to compilers-request@iecc.com.


From chase@Think.COM Fri Dec 17 12:07:00 MST 1993
Article: 3424 of comp.compilers
Xref: yuma comp.compilers:3424 comp.arch:19273
Newsgroups: comp.compilers,comp.arch
Path: yuma!purdue!lerc.nasa.gov!usenet.ins.cwru.edu!eff!news.kei.com!world!iecc!compilers-sender
From: chase@Think.COM (David Chase)
Subject: Re: SPARC code generation for compiler course
Message-ID: <93-12-073@comp.compilers>
Keywords: sparc, architecture
Sender: compilers-sender@chico.iecc.com
Organization: Thinking Machines Corporation, Cambridge MA, USA
References: <93-12-040@comp.compilers> <93-12-072@comp.compilers>
Date: Thu, 16 Dec 1993 20:49:11 GMT
Approved: compilers@chico.iecc.com
Lines: 67

nickh@harlequin.co.uk (Nick Haines) writes:
|> When adhering to the ABI, the meaning is not clear, and probably requires
|> reading the Sparc ABI definition. Any Sun experts out there want to
|> comment?  My non-expert eye says that g1 is caller-save, g2-g4 are up to
|> the compiler writer (caller-save, or global variables, or some kind of
|> program state; this is what is meant by "the execution environment"
|> elsewhere in the manual) and g5-g7 are "reserved" to the ABI (although how
|> the ABI copes with non-conforming code is unstated).

Note that the ABI officially only applies to Solaris 2.* (aka SunOS 5.*)
system, though most of the conventions being discussed here are followed
in SunOS 4.*.

%g1 is "extremely volatile", meaning that it is used as a scratch register
by the code in a procedure linkage table (that is, the code that you
execute to call a subroutine in a shared library, or to call out of a
shared library).


%g2-%g4 are, as near as I can tell, up for grabs.  The ABI is pretty
ambiguous about this, except in the case of system library code -- that
code must leave those registers alone.  In general, I think they make fine
(caller-saves) temporaries, though that conflicts with global register
assignment.  However, since one global register assignment conflicts with
another global register assignment, I regard that as special purpose
(useless in libraries, for instance).

I think that there was some intent that these registers might be used to
support (for example) run-time systems for Lisp or Prolog, but from the
point of view of C and Fortran programmers, those languages are
(unfortunately) insignificant and ignorable.  Furthermore, there are fine
Lisp/Scheme implementations available that do not use those registers
anyway, so perhaps it was not necessary to reserve them for this purpose
in the first place.  There are also Scheme (and other language)
implementations that work by first compiling to C, so (in those cases)
what is good for C is good for Scheme.

One fun, non-compiler use of the registers is to pass hidden parameters
from thunks (I posted something on this to comp.compilers earlier this
year).  There, it must be possible to get a guarantee from the compiler
that %g2-%g4 (or some subset of those) is not trashed within the code
generated for a particular subroutine, because they must be preserved up
to the point where the subroutine reads them.  Note that this is still
compatible with other subroutines using these registers as caller-saves
temps.

Note that the ABI will continue to work, no matter how you abuse %g2-%g4.
However, your piece of code might not work with someone else's piece of
code.


Don't mess with %g5-%g7, ever.  The run-time system might use them to
implement (for example) thread-local storage, or some such.  Remember that
no matter what the various standards may say about it, all sorts of
interesting code is run within signal handlers.  Other uses of these
registers include enabling various patched-binary profiling tools.  Even
if it works for you today, in a particular situation, there is no
guarantee that it will continue to work with the next revision of the OS,
libc, or whatever.  "Not work" means "segmentation violation" when (e.g.)
some piece of code tries to set the thread-local errno, and writes to page
zero instead.

David Chase, speaking for myself
Thinking Machines Corp.
-- 
Send compilers articles to compilers@iecc.com or
{ima | spdcc | world}!iecc!compilers. Meta-mail to compilers-request@iecc.com.


From pardo@cs.washington.edu Fri Dec 17 12:07:28 MST 1993
Article: 3426 of comp.compilers
Xref: yuma comp.compilers:3426 comp.arch:19274
Newsgroups: comp.compilers,comp.arch
Path: yuma!purdue!lerc.nasa.gov!usenet.ins.cwru.edu!eff!news.kei.com!world!iecc!compilers-sender
From: pardo@cs.washington.edu (David Keppel)
Subject: Re: SPARC code generation for compiler course
Message-ID: <93-12-075@comp.compilers>
Keywords: sparc, architecture
Sender: compilers-sender@chico.iecc.com
Organization: Computer Science & Engineering, U. of Washington, Seattle
References: <93-12-040@comp.compilers> <93-12-072@comp.compilers>
Date: Fri, 17 Dec 1993 00:04:38 GMT
Approved: compilers@chico.iecc.com
Lines: 55

nickh@harlequin.co.uk (Nick Haines) writes:
>[Which SPARC %g registers are caller-save?]

My reading of page 192 of

%T The SPARC\s-2\uTM\d\s+2 Architecture Manual, Version 8
%Q SPARC International
%I Prentice Hall
%D 1992

is that

	%g0 is always zero
	%g1 is caller-save
	%g2-%g4 are reserved for application use
	%g5-%g7 are reserved for OS use

The application can use any protocol for %g2-%g4.  Most applications today
ignore them.  However, %g2-%g4 may, for example, contain values that are
changed in the callee, and used in the caller.  Or, they could be used as
caller-save or as callee-save registers.  Or, they might have values used
asynchronously and, therefore, could never otherwise be modified by the
application.  Finally, the registers could be used one way in one part of
the application and a different way in another part of the application.
However, any such use is assumed to be per-application and the usage
conventions are assumed to be pervasive throughout the application.

%g5-%g7 are used by the ABI.  They have arbitrary values that are changed
at arbitrary times (e.g., by asynchronous signal handlers) and must not be
modified by an application.  Any application that writes these registers
is noncompliant.

That's my reading of it, anyway.


>[How does the ABI cope with non-conforming code?]

It promises nothing; it likewise promises nothing if you read a register
without first writing it.


You might also want to read

%Q AT&T
%T System V Application Binary Interface SPARC Processor Supplement
%D 1990
%I Prentice-Hall

I don't have a copy of it, so I don't know it has more to say about
register conventions.

	;-D on  ( It finally registered... )  Pardo
-- 
Send compilers articles to compilers@iecc.com or
{ima | spdcc | world}!iecc!compilers. Meta-mail to compilers-request@iecc.com.


